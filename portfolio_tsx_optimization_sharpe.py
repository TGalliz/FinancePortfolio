# -*- coding: utf-8 -*-
"""Portfolio_TSX_try1.ipynb

Automatically generated by Colaboratory.=        

Original file is located at
    https://colab.research.google.com/drive/1TW1uIOY15kdcT-WhoordbWSAK-bkKe8U
"""

# Commented out IPython magic to ensure Python compatibility.
# Installs
# %pip install yfinance
# %pip install PyPortfolioOpt
#%pip install pulp

#Imports
import pandas as pd
import numpy as np
import requests
import SupportFuncFinance as sup
import pickle
import yfinance as yf

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models

from pypfopt import expected_returns
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

from pypfopt import plotting

  
#%%

#%% Download data and clean up missing data
#data_tsx = yf.download(df['TorontoTicker'].tolist(),start=start_date,end=end_date)
#%%
#data_tsx.to_pickle('data_tsx.pkl')

data_tsx = pickle.load(open('data_tsx.pkl','rb'))

#%%
data_tsx = sup.cleanup_yahoodataframe(data_tsx)       

#%%
mu_tsx = expected_returns.mean_historical_return(data_tsx)                                                 
s_tsx = risk_models.sample_cov(data_tsx)
#%%
#Create the Efficient Frontier Object
ef_tsx = EfficientFrontier(mu_tsx, s_tsx)
weights_tsx = ef_tsx.max_sharpe()

cleaned_weights_tsx = ef_tsx.clean_weights()
ef_tsx.portfolio_performance(verbose=True)

#%%
# ret_09 = ef_tsx.efficient_return(0.9)
# ret_09 = sup.clean_dict(ret_09)

# ret_05 = ef_tsx.efficient_return(0.5)
# ret_05 = sup.clean_dict(ret_05)

# ret_01 = ef_tsx.efficient_return(0.1)
# ret_01 = sup.clean_dict(ret_01)
#%%
# Get the discrete allocation of each share per stock

prices = data_tsx.iloc[0,:]
weights_tsx = cleaned_weights_tsx
da_tsx = DiscreteAllocation(weights_tsx, prices, total_portfolio_value = portfolio_val)
allocation_tsx, leftover_tsx = da_tsx.lp_portfolio()
print('Discrete Allocation:', allocation_tsx)
print('Funds remaining: $', leftover_tsx )

#%%
#Store the company name into a list
company_name_tsx = []

#Get the discrte allocation values
discrete_allocation_list_tsx = []
for symbol in allocation_tsx:
  discrete_allocation_list_tsx.append(allocation_tsx.get(symbol))
  company_name_tsx.append(df.loc[df['TorontoTicker']==symbol]['Name'].item())

portfolio_df_tsx = pd.DataFrame(columns = ['Company_name', 'Company_Ticker','Discrete_val_'+str(portfolio_val)])

portfolio_df_tsx['Company_name'] = company_name_tsx 
portfolio_df_tsx['Company_Ticker'] = allocation_tsx 
portfolio_df_tsx['Discrete_val_'+str(portfolio_val)] = discrete_allocation_list_tsx
portfolio_df_tsx.sort_values(by='Discrete_val_'+str(portfolio_val),ascending=False)



#%%
portfolio = data_tsx[portfolio_df_tsx['Company_Ticker']]
portfolio.dropna(axis=0,how='all')

import math

for row in portfolio.iterrows():
    if math.isnan(row[1][0]):
        portfolio =portfolio.drop(row[0],axis=0)

portfolio_scale = portfolio.copy(deep=True)

for x in portfolio_scale:
    val = portfolio_df_tsx.loc[portfolio_df_tsx['Company_Ticker']==x]['Discrete_val_10000'].iloc[0]
    portfolio_scale[x] = val * portfolio_scale[x]


portfolio_scale['SUM'] = portfolio_scale.sum(axis=1)
portfolio_scale.dropna(axis=0,how='all')


#%%
data_spy = yf.download('SPY', start = start_date, end = end_date)

data_spy = sup.cleanup_yahoodataframe(data_spy)

data_spy = data_spy * (portfolio_val/data_spy.iloc[0,0])
# data_spy = data_spy - data_spy.iloc[0,0]

#%%
import matplotlib.pyplot as plt
import matplotlib as mpl

valid_markers = ([item[0] for item in mpl.markers.MarkerStyle.markers.items() if
item[1] != 'nothing' and not item[1].startswith('tick') and not item[1].startswith('caret')])

markers = np.random.choice(valid_markers, df.shape[1], replace=False)

ax =plt.plot(data_spy)
ax =plt.plot(portfolio_scale,marker =1,ms=3,markevery=50)
    
legend = portfolio_scale.columns.values.tolist()
legend.insert(0,'SPY')
ax.legend(legend, loc='best')
plt.xlabel('Time')
plt.ylabel('$$$')
plt.show()
